% !TeX root = ../thesis.tex
\chapter{基于Gossip-Style Membership协议的P2P系统的Go语言实现}\label{app:code}
附录~\ref{app:code}中仅展示与$\mathbb{RVPC}_{\mathbb{Th}}$有关的部分，
若要运行完整代码，可以移步

\url{https://github.com/Angeladadd/AGossipStyleMembershipProtocolImplementedUsingRVPC}。

Node的Go语言实现。
\begin{codeblock}[language=GO]
	package simple

	import (
		"fmt"
		"math/rand"
		"time"
	)
	
	const (
		P_FAIL=0.1
		GOSSIP_INTERVAL=time.Second //1sGossip一次
		REPAIR_TIME=4*time.Second //BadNode恢复时间
		NODE_NUM = 5 //节点数目
		BUFSIZE = 4 //channel buffer size 一般设置为数据中心节点的数目即可
		K = 2
		IS_AUTO = false //展示用
	)
	
	type Nil struct {}
	
	type Node struct {
		isbad bool
		trans chan []Message
		time chan Nil
		timeout chan Nil
		accept chan []Message
		deliver chan []Message
		Others []*Node
		//仅打日志及图形化显示使用
		address string
		membership *Membership
	}
	
	func NewNode(address string) (instance *Node) {
		instance = new(Node)
		instance.accept = make(chan []Message)
		instance.deliver = make(chan []Message)
		instance.trans = make(chan []Message, BUFSIZE)
		instance.time = make(chan Nil)
		instance.timeout = make(chan Nil)
		instance.isbad = false
		instance.address = address
		instance.Others = make([]*Node, 0)
		instance.membership = NewMembership(address, instance.accept, instance.deliver)
		fmt.Printf("Initialized Node %p\n", instance)
		return
	}
	
	//多路复用实现Nondeterminated Choice
	func (node *Node) Fragile() {
		fmt.Printf("Node %p Starts\n", node)
		go node.timer()
		go node.membership.Running()
		node.time <- Nil{}
		for {
			if (IS_AUTO) {
				node.Bad()
			}
			if (node.isbad) {
				time.Sleep(REPAIR_TIME)
				continue
			}
			select {
			case message := <- node.trans:
				node.deliver <- message
				for len(node.trans) > 0 {
					message = <- node.trans
					node.deliver <- message
				}
			case <- node.timeout:
				messages := <- node.accept
				rand.Seed(time.Now().UnixNano())
				perm := rand.Perm(len(node.Others))[:K]
				var targets []*Node
				for _, p := range perm {
					targets = append(targets, node.Others[p])
				}
				node.Gossiping(messages, targets)
			}
		}
	}
	func (node *Node) Bad() {
		rand.Seed(time.Now().UnixNano())
			r := rand.Float32()
			if r < P_FAIL {
				node.isbad = true
			} else {
				node.isbad = false
			}
	}
	
	func (node *Node) timer() {
		for {
			select {
			case <- node.time:
				time.Sleep(GOSSIP_INTERVAL)
				node.timeout <- Nil{}
			}
		}
	}
	
	func (node *Node) Gossiping(messages []Message, targets []*Node) {
		var str string
		for _, t := range targets {
			if (len(t.trans) == BUFSIZE) {
				continue
			}
			t.trans <- messages
			str+=(t.address+" ")
		}
		fmt.Printf("[SEND] From: %s; To: %s\n", node.address, str)
		node.time <- Nil{}
	}
	
	func transmitting(messages []Message, targets []*Node) string {
		var str string
		for _, t := range targets {
			if (len(t.trans) == BUFSIZE) {
				continue
			}
			t.trans <- messages
			str+=(t.address+" ")
		}
		return str
	}
	
	func (node *Node)ChangeStatus() {
		node.isbad = !node.isbad
	}
	
	func (node *Node)Address() string {
		return node.address
	}
\end{codeblock}

main的Go语言实现，主要包含了多个节点并发执行的逻辑。
\begin{codeblock}[language=GO]
	package main

	import (
		"encoding/json"
		"fmt"
		"./simple"
		"strconv"
		"log"
		"net/http"
		"io/ioutil"
	)
	
	var nodes []*simple.Node
	
	func main() {
		nodes = make([]*simple.Node, 0)
		for i:=0;i<simple.NODE_NUM;i++ {
			nodes = append(nodes, simple.NewNode("address"+strconv.Itoa(i)))
		}
	
		for i:=0;i<simple.NODE_NUM;i++ {
			nodes[i].Others = append(nodes[i].Others, nodes[:i]...)
			nodes[i].Others = append(nodes[i].Others, nodes[i+1:]...)
			go nodes[i].Fragile()
		}
	
		for {
		}
	}
\end{codeblock}

Membership的Go语言实现。
由于Node，main的Go语言实现已经可以很好的起到Demo的作用，
且考虑到代码的效率，没有必要使
小规模且本地顺序执行的的Membership中的每一个Cell并发执行，
Membership的具体实现与文中定义不完全相同。
\begin{codeblock}[language=GO]
	package simple

	import (
		"time"
		"fmt"
	)
	
	type Message struct {
		Address string
		Heartbeat int
	}
	
	type Cell struct {
		Message Message
		LocalTime int64
	}
	
	type Membership struct {
		address string
		heartbeat int
		membershipList map[string]Cell
		accept chan []Message
		deliver chan []Message
	}
	
	func NewMembership(address string, accept chan []Message, deliver chan[]Message) (instance *Membership){
		instance = new(Membership)
		instance.address = address
		instance.heartbeat = 0
		instance.membershipList = make(map[string]Cell,0)
		instance.accept = accept
		instance.deliver = deliver
		fmt.Printf("Initialzed Membership %p\n", instance)
		return
	}
	
	func (membership *Membership) Running() {
		for {
			select {
			case messages := <- membership.deliver:
				membership.Deliver(messages)
			case membership.accept <- membership.Accept():
	
			}
		}
	}
	
	func (membership *Membership) Deliver(messages []Message) {
		list := membership.membershipList
		for _, message := range messages {
			if message.Address == membership.address {
				continue
			}
			if cell, ok := list[message.Address]; !ok || (cell.Message.Heartbeat < message.Heartbeat) {
				//MembershipList中没有这个节点的信息或信息是旧的，增加或更新
				list[message.Address] = Cell{Message:Copy(message), LocalTime:time.Now().UnixNano()}
			} 
		}
		membership.PrintUpdate()
	}
	
	func (membership *Membership) Accept() (messages []Message) {
		list := membership.membershipList
		messages = make([]Message, 0)
		membership.heartbeat++
		messages = append(messages, Message{membership.address, membership.heartbeat})
		for _, cell := range list {
			messages = append(messages, Copy(cell.Message))
		}
		return
	}
\end{codeblock}